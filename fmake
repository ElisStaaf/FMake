#!/bin/python3

"""
Convert "fmake" language to standard
"m4" macro processing.

author :: Elis Staaf
python :: >=3.0
license :: Apache 2.0 License
"""

import sys
import os

if sys.version_info < (3, 0):
    print("[ERROR]: Python3 is required to use FMake.")
    exit(1)

help = """usage: fmake [-S] [-h, --help]
flags:
    -h, --help: Show this help screen.
    -S: Save all tmp files."""

class Fmake:
    def __init__(self, filename: str) -> None:
        with open(filename, "r") as file:
            self.lines: list[str] = file.readlines()
            file.close()
        self.program: list[str] = [] # <- This holds the program, which
                                     # is then written to a tmp file.

    def cwd_node(self, index) -> str:
        return f"{os.getcwd()}/{self.nodelist[index]}"

    def eval_expr(self) -> None:
        for line in self.lines:
            # We use .rstrip() here because otherwise the list has the weird
            # newline character at the end, which makes the tmp files go crazy.
            self.nodelist: list[str] = line.rstrip("\n").split(" ")
            startnode: str = self.nodelist[0]
            if startnode == "gcc-build":
                self.program.append(f"_gcc_build(`{self.cwd_node(1)}', `{self.cwd_node(2)}')")
            elif startnode == "go-build":
                self.program.append(f"_go_build(`{self.cwd_node(1)}', `{self.cwd_node(2)}')")
            elif startnode == "rust-build":
                self.program.append(f"_rust_build(`{self.cwd_node(1)}', `{self.cwd_node(2)}')")
            elif startnode == "g++-build":
                self.program.append(f"_gpp_build(`{self.cwd_node(1)}', `{self.cwd_node(2)}')")
            elif startnode.startswith("--") or startnode.strip() == "":
                continue
            else:
                print("[ERROR]: Invalid syntax")

# If fmake *is* provided; return
# that filename as string.
def fmake_provided() -> list[bool|str]:
    for item in os.listdir():
        match item.lower():
            case "fmakefile":
                return [True, item]
    return [False]

def invoke(program: list[str]) -> None:
    with open(f"{os.getcwd()}/tmp.m4", "w+") as macros:
        macros.write("\n".join(program)) # Write program to tmp file.
        macros.close()
    try:
        # Firstly, we run the m4 interpeter to a tmp.sh file,
        # then we invoke the tmp.sh file and lastly, we delete
        # all of the tmp files using "tmp*"
        os.system(f"m4 m4/build.m4 tmp.m4 > {os.getcwd()}/tmp.sh")
        os.system("sh tmp.sh") 
    except:
        print("[ERROR]: Ending compilation...")

def del_tmp() -> None:
    os.system(f"rm {os.getcwd()}/tmp*")

def main() -> None:
    if not fmake_provided()[0]:
        print("[ERROR]: No FMakefile provided.")
        exit(1)
    fmake = Fmake(fmake_provided()[1])
    if len(sys.argv) <= 1:
        fmake.eval_expr()
        invoke(fmake.program)
        del_tmp()
        exit(0)
    match sys.argv[1]:
        case "-S":
            fmake.eval_expr()
            invoke(fmake.program)
        case "-h" | "--help":
            print(help)
        case _:
            print("Invalid flag.\nType \"fmake --help\" for more information.")

if __name__ == "__main__":
    main()
